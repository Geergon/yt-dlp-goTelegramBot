package tgbot

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/celestix/gotgproto/ext"
	"github.com/gotd/td/tg"
)

func addSubtitle(width int, height int, textBottom string, textTop, dir string) error {
	var fontSize, outline int

	switch {
	case height >= 720:
		fontSize = 44
		outline = 10
	default:
		fontSize = 24
		outline = 3
	}

	assTemplate := fmt.Sprintf(`[Script Info]
Title=Generated by ytdlp-gotelegrambot
ScriptType=v4.00+
PlayResX=%d
PlayResY=%d
ScaledBorderAndShadow=yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Top,DejaVu Sans,%d,&H00FFFFFF,&H000000FF,&H00000000,&H32000000,-1,0,0,0,100,100,0,0,1,%d,0,8,50,50,0,1
Style: Bottom,DejaVu Sans,%d,&H00FFFFFF,&H000000FF,&H00000000,&H32000000,-1,0,0,0,100,100,-1,0,1,%d,0,2,50,50,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,9:59:59.00,Bottom,,0,0,0,,%s
Dialogue: 0,0:00:00.00,9:59:59.00,Top,,0,0,0,,%s
`, width, height, fontSize, outline, fontSize, outline, textBottom, textTop)

	filename := "output.ass"

	path := filepath.Join(dir, filename)

	err := os.WriteFile(path, []byte(assTemplate), 0644)
	if err != nil {
		log.Println("не вдалося записати ass файл")
		return err
	}
	return nil
}

func GetVideo(ctx *ext.Context, update *ext.Update) (string, string, error) {
	msg := update.EffectiveMessage

	dir, err := os.MkdirTemp("", "audio-download-")
	if err != nil {
		log.Printf("Помилка створення тимчасового каталогу: %v", err)
		return "", "", err
	}

	if msg.Media == nil {
		os.RemoveAll(dir)
		log.Println("повідомлення не містить медіа")
		return "", "", err
	}

	mediaDoc, ok := msg.Media.(*tg.MessageMediaDocument)
	if !ok {
		os.RemoveAll(dir)
		log.Println("медіа не є документом")
		return "", "", err
	}

	doc, ok := mediaDoc.Document.(*tg.Document)
	if !ok {
		os.RemoveAll(dir)
		log.Println("не вдалося отримати документ")
		return "", "", err
	}

	isVideo := false
	var filename string

	for _, attr := range doc.Attributes {
		switch a := attr.(type) {
		case *tg.DocumentAttributeVideo:
			isVideo = true
			log.Printf("Відео: %dx%d, тривалість: %d сек", a.W, a.H, a.Duration)
		case *tg.DocumentAttributeFilename:
			filename = a.FileName
		}
	}

	if !isVideo {
		os.RemoveAll(dir)
		log.Println("документ не є відео")
		return "", "", err
	}

	if filename == "" {
		filename = fmt.Sprintf("video_%d.mp4", doc.ID)
	}

	log.Printf("Завантажуємо відео: %s (%d bytes)", filename, doc.Size)

	path := filepath.Join(dir, filename)

	file, err := os.Create(path)
	if err != nil {
		os.RemoveAll(dir)
		log.Println("не вдалося створити файл: ", err)
		return "", "", err
	}

	maxRetries := 3
	var downloadErr error

	for i := 0; i < maxRetries; i++ {
		if i > 0 {
			log.Printf("Повторна спроба завантаження (%d/%d)...", i+1, maxRetries)
			time.Sleep(time.Second * 2) // Пауза перед retry

			// Перевідкрити файл
			file.Close()
			file, err = os.Create(path)
			if err != nil {
				os.RemoveAll(dir)
				return "", "", fmt.Errorf("не вдалося перевідкрити файл: %w", err)
			}
		}

		// Спроба завантажити
		_, downloadErr = ctx.DownloadMedia(
			mediaDoc,
			&ext.DownloadOutputStream{Writer: file},
			&ext.DownloadMediaOpts{
				Threads: 1, // Використовувати 1 потік для стабільності
			},
		)

		if downloadErr == nil {
			// Успішно завантажено
			break
		}

		log.Printf("Помилка завантаження (спроба %d): %v", i+1, downloadErr)
	}

	file.Close()

	if downloadErr != nil {
		os.RemoveAll(dir)
		return "", "", fmt.Errorf("не вдалося завантажити після %d спроб: %w", maxRetries, downloadErr)
	}

	log.Printf("Відео збережено: %s", path)

	return dir, filename, nil
}

func MakeGif(dir string, filename string, textbott string, texttop string) (string, error) {
	path := filepath.Join(dir, filename)
	width, height, err := GetVideoResolution(path)
	if err != nil {
		log.Println("помилка при отриманні video resolution: ", err)
		return "", err
	}

	err = addSubtitle(width, height, textbott, texttop, dir)
	if err != nil {
		fmt.Println("помилка при створенні субтритрів для gif: ", err)
		return "", err
	}

	assFilePath := filepath.Join(dir, "output.ass")

	ass := fmt.Sprintf("ass=%s", assFilePath)

	output := fmt.Sprintf("gif-%s", filename)
	outputPath := filepath.Join(dir, output)

	args := []string{
		"-i", path,
		"-vf", ass,
		"-an", outputPath,
	}

	cmd := exec.Command("ffmpeg", args...)
	o, err := cmd.CombinedOutput()
	if err != nil {
		log.Printf("ffmpeg error: %v\nOutput: %s", err, string(o))
		return "", err
	}

	log.Printf("ffmpeg успішно обробив файл: %s", filename)
	return output, nil
}

func GetVideoResolution(path string) (int, int, error) {
	args := []string{
		"-v", "error",
		"-select_streams", "v:0",
		"-show_entries", "stream=width,height",
		"-of", "csv=s=x:p=0",
		path,
	}

	cmd := exec.Command("ffprobe", args...)
	o, err := cmd.CombinedOutput()
	if err != nil {
		log.Printf("ffmpeg error: %v\nOutput: %s", err, string(o))
		return 0, 0, fmt.Errorf("ffprobe failed: %w", err)
	}

	result := strings.TrimSpace(string(o))
	if result == "" {
		return 0, 0, fmt.Errorf("ffprobe повернув порожній результат")
	}

	parts := strings.Split(result, "x")
	if len(parts) != 2 {
		return 0, 0, fmt.Errorf("неправильний формат виводу: %s", result)
	}

	width, err := strconv.Atoi(parts[0])
	if err != nil {
		return 0, 0, fmt.Errorf("не вдалося конвертувати ширину '%s': %w", parts[0], err)
	}

	height, err := strconv.Atoi(parts[1])
	if err != nil {
		return 0, 0, fmt.Errorf("не вдалося конвертувати висоту '%s': %w", parts[1], err)
	}

	log.Printf("Роздільність відео: %dx%d", width, height)

	return width, height, nil
}
